include::../shared-settings.adoc[]
include::../header.adoc[]

:numbered!:
== How to use RDF and the Eclipse RDF4J Framework

Getting started with RDF can be hard. In this tutorial, we go through the basics of what RDF is and how you can use it, and we show how you can use the Eclipse RDF4J framework to create, process, store, and query RDF data. We assume that you know a little about programming in Java, but no prior knowledge on what RDF is is assumed.

The code examples in this tutorial are available for download from the https://github.com/eclipse/rdf4j-doc/examples[rdf4j-doc GitHub repository]. We encourage you to download these examples and play around with them.

:numbered:
== Introducing RDF

The https://www.w3.org/TR/rdf11-primer/[Resource Description Framework (RDF)] is a standard (or more accurately, a "recommendation") formulated by the https://www.w3.org/[World Wide Web Consortium (W3C)], the same organization that developed HTTP, HTML, and XML. The purpose of RDF is to provide a framework for expressing information about resources.

A _resource_ can be anything that we can stick an identifier on: a web page, an image, but also more abstract/real-world things like you, me, the concept of "world peace", the number 42, and that library book you never returned. 

RDF is intended for modeling information that needs to processed by applications, rather than just being shown to people. 

In this tutorial, we will be modeling information about artists . Let's start with a simple fact: "Picasso's first name is Pablo". In RDF, this could be expressed as follows:

image:rdf-graph-1.png[]

So what exactly are we looking at here? Well, we have a _resource_ "Picasso", denoted by an IRI (Internationalized _Resource Identifier_): `http://example.org/Picasso`. In RDF, resources have _properties_. Here we are using the `foaf:firstName` property to denote the relation between the resource "Picasso" and the value "Pablo". `foaf:firstName` is also an IRI, though to make things easier to read we use an abbreviated syntax, called _prefixed names_ (more about this later). Finally, the property value, "Pablo", is a _literal_ value: it is not represented using a resource identifier, but simply as a string of characters.

As you may have noticed, we have depicted our fact about Picasso as a simple *graph*: two nodes, connected by an edge. It is very helpful to think about RDF models as graphs, and a lot of the tools we will be using to create and query RDF data make a lot more sense if you do.

In RDF, each fact is called a *statement*. Each statement consists of three parts (for this reason, it is also often called a _triple_):

* the _subject_ is the starting node of the statement, representing the resource that the fact is "about";
* the _predicate_ is the property that denotes the edge between two nodes;
* the _object_ is the end node of the statement, representing the resource or literal that is the _property value_.

Let's expand our example slightly: we don't just have a single statement about Picasso, we know another fact as well: "Picasso is an artist". We can extend our RDF model as follows:

image:rdf-graph-2.png[]

Notice how the second statement was added to our graph depiction by simply adding a second edge to an already existing node , labeled with the `rdf:type` property, and the value `ex:Artist`. As you continue to add new facts to your data model, nodes and edges continue to be added to the graph.

=== IRIs, namespaces, and prefixed names

IRIs are at the core of what makes RDF powerful. They provide a mechanism that allows global identification of any resource: no matter who authors a dataset or where that data is physically stored, if that data shares an identical IRI with another dataset you know that both datasets are talking about the same thing. 

You will often see IRIs in abbreviated form whenever you encounter examples of RDF data: `<prefix>:<name>` This abbreviated form, known as "prefixed names", has no impact on the meaning of the data, but it makes it easier for people to read the data. 

Prefixed names work by defining a _prefix_ that is a replacement for a _namespace_. A namespace is the first part of an IRI that is shared by several resources. For example, the IRIs `http://example.org/Picasso`, `http://example.org/Rodin`, and `http://example.org/Rembrandt` all share the the namespace `http://example.org/`. By defining a new prefix `ex` as the abbreviation for this namespace, we can use the string `ex:Picasso` instead of its full IRI.

== Using RDF4J to create RDF models

Eclipse RDF4J is a Java API for RDF: it allows you to create, parse, write, store, query and reason with RDF data in a highly scalable manner. So let's see two examples of how we can use RDF4J to create the above RDF model in Java.

=== Example 01: building a simple Model 

https://github.com/eclipse/rdf4j-doc/examples/src/main/java/org/eclipse/rdf4j/examples/model/Example01BuildModel.java[Example 01] shows how we can create the RDF model we introduced above using RDF4J:

[[code-example-01]]
[source,java,linenums]
----
// We use a ValueFactory to create the building blocks of our RDF statements: 
// IRIs, blank nodes and literals.
ValueFactory vf = SimpleValueFactory.getInstance();

// We want to reuse this namespace when creating several building blocks.
String ex = "http://example.org/";

// Create IRIs for the resources we want to add.
IRI picasso = vf.createIRI(ex, "Picasso");
IRI artist = vf.createIRI(ex, "Artist");

// Create a new, empty Model object.
Model model = new TreeModel();

// add our first statement: Picasso is an Artist
model.add(picasso, RDF.TYPE, artist);

// second statement: Picasso's first name is "Pablo".
model.add(picasso, FOAF.FIRST_NAME, vf.createLiteral("Pablo"));
----

Let's take a closer look at this. Lines 1-10 are necessary preparation: we use a `ValueFactory` to create resources , which we will later use to add facts to our model. 

On line 13, we create a new, empty model. RDF4J comes with several `Model` implementations, the ones you will most commonly encounter are `TreeModel` and `LinkedHashModel`. The difference is in how they index data internally - which has a performance impact when working with very large models. For our purposes however, it doesn't really matter which implementation you use.

On lines 16 and 19, we add our two facts that we know about Picasso: that's he's an artist, and that his first name is "Pablo". 

In RDF4J, a `Model` is simply an in-memory collection of RDF statements. We can add statements to an existing model, remove statements from it, and of course iterate over the model to do things with its contents. As an example, let's iterate over all statements in our `Model` using a `for-each` loop, and print them to the screen:

[source, java, linenums]
----
for (Statement statement: model) {
    System.out.println(statement);
}
----

When you run this, the output will look something like this:

----
(http://example.org/Picasso, http://xmlns.com/foaf/0.1/firstName, "Pablo"^^<http://www.w3.org/2001/XMLSchema#string>) [null]
(http://example.org/Picasso, http://www.w3.org/1999/02/22-rdf-syntax-ns#type, http://example.org/art/Artist) [null]
----

Not very pretty perhaps, but at least you should be able to recognize the RDF statements that we originally added to our model. Each line is a single statement, with the subject, predicate, and object value in comma-separated form. The `[null]` behind each statement is a context identifier or named graph identifier, which you can safely ignore for now. The bit `^^<http://www.w3.org/2001/XMLSchema#string>` is a _datatype_ that RDF4J assigned to the literal value we added (in this case, the datatype is simply string). 

=== Example 02: using the ModelBuilder

The previous code example shows that you need to do a bit of prep on your data before actually adding anything to your model: defining common namespaces, creating a `ValueFactory`, creating IRIs, etc. As a convenience, RDF4J provides a `ModelBuilder` that simplifies things.

https://github.com/eclipse/rdf4j-doc/examples/src/main/java/org/eclipse/rdf4j/examples/model/Example02BuildModel.java[Example 02] shows how we can create the exact same model using a `ModelBuilder`:

[[code-example-02]]
[source, java, linenums]
----
ModelBuilder builder = new ModelBuilder();
Model model = builder
                  .setNamespace("ex", "http://example.org/")
		  .subject("ex:Picasso")
		       .add(RDF.TYPE, "ex:Artist")
		       .add(FOAF.FIRST_NAME, "Pablo")
		  .build();
----

The above bit of code creates the exact same model that we saw in link:#code-example-01[code example 01], but with far less prep. `ModelBuilder` accepts IRIs and prefixed names supplied as simple Java strings. On line 3 we define a namespace prefix we want to use, and then on lines 4-6 we use simple prefixed name strings, which the `ModelBuilder` internally maps to full IRIs.

== Blank nodes

Sometimes, we may want to model some facts without explicitly giving all resources involved in that fact an identifier. For example, consider the following sentenct: "Picasso has created a painting depicting cubes, and using a blue color scheme". There's several facts in this sentence:

1. Picasso created some painting;
2. that painting depicts cubes;
3. that painting uses the color blue.

All of the above may be true, but it doesn't involve identifying a specific painting. All we know is that there is _some_ (unknown) painting for which all of this is true. We can express this in RDF using a *blank node*.

When looking at a graph depiction of the RDF, it becomes obvious why it is called a _blank_ node:

image:rdf-graph-3.png[]

Other possible uses for blank nodes are for modeling a collection of facts that are strongly tied together. For example, "Picasso's home address is '31 Art Gallery, Madrid, Spain'" could be modeled as follows:

image:rdf-graph-4.png[]

=== Example 03: adding blank nodes to a Model

https://github.com/eclipse/rdf4j-doc/examples/src/main/java/org/eclipse/rdf4j/examples/model/Example03BlankNode.java[Example 03] shows how we can add the address of Picasso to our Model:

[[code-example-03]]
[source,java,linenum]
----
// To create a blank node for the address, we need a ValueFactory
ValueFactory vf = SimpleValueFactory.getInstance();
BNode address = vf.createBNode();

// First we do the same thing we did in example 02: create a new ModelBuilder,
// and add two statements about Picasso.
ModelBuilder builder = new ModelBuilder();
builder
    .setNamespace("ex", "http://example.org/")
    .subject("ex:Picasso")
	    .add(RDF.TYPE, "ex:Artist")
	    .add(FOAF.FIRST_NAME, "Pablo")
    // this is where it becomes new: we add the address by linking the blank 
    // node to picasso via the `ex:homeAddress` property, and then adding 
    // facts _about_ the address
	    .add("ex:homeAddress", address) // link the blank node
    .subject(address)			    // switch the subject
	    .add("ex:street", "31 Art Gallery")
	    .add("ex:city", "Madrid")
	    .add("ex:country", "Spain");

Model model = builder.build();
----


== Reading and Writing RDF

In the previous sections we saw how to print the contents of a Model to the screen, However, this is of limited use: the format is not easy to read, and certainly not by any other tools that you may wish to share the information with.

Fortunately, RDF4J provides tools for reading and writing RDF models in several syntax formats, all of which are standardized, and therefore can be used to share data between applications. The most commonly used formats are RDF/XML, Turtle, and N-Triples.

=== Example 04: Writing to RDF/XML 

https://github.com/eclipse/rdf4j-doc/examples/src/main/java/org/eclipse/rdf4j/examples/model/Example04WriteRdfXml.java[Example 04] shows how we can write our Model as RDF/XML, using the RDF4J Rio parser/writer tools:

[[code-example-04]]
[source, java]
----
Rio.write(model, System.out, RDFFormat.RDFXML);
----

The output will be similar to this:

[[code-example-04-output]]
[source, xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<rdf:RDF
	xmlns:ex="http://example.org/"
	xmlns:xsd="http://www.w3.org/2001/XMLSchema#"
	xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">

<rdf:Description rdf:about="http://example.org/Picasso">
	<rdf:type rdf:resource="http://example.org/Artist"/>
	<firstName xmlns="http://xmlns.com/foaf/0.1/" rdf:datatype="http://www.w3.org/2001/XMLSchema#string">Pablo</firstName>
	<ex:homeAddress rdf:nodeID="node1b4koa8edx1"/>
</rdf:Description>

<rdf:Description rdf:nodeID="node1b4koa8edx1">
	<ex:street rdf:datatype="http://www.w3.org/2001/XMLSchema#string">31 Art Gallery</ex:street>
	<ex:city rdf:datatype="http://www.w3.org/2001/XMLSchema#string">Madrid</ex:city>
	<ex:country rdf:datatype="http://www.w3.org/2001/XMLSchema#string">Spain</ex:country>
</rdf:Description>

</rdf:RDF>
----

The `Rio.write` method takes a `java.io.OutputStream` or a `java.io.Writer` as an argument, so if we wish to write to file instead of to the screen, we can simply use a `FileOutputStream` or a `FileWriter` and point it at the desired file location.

=== Example 05: Writing to Turtle and other formats

https://github.com/eclipse/rdf4j-doc/examples/src/main/java/org/eclipse/rdf4j/examples/model/Example05WriteTurtle.java[Example 05] shows how we can write our Model in the Turtle syntax format:

[[code-example-05]]
[source, java]
----
Rio.write(model, System.out, RDFFormat.TURTLE);
----

To produce other syntax formats, simply vary the supplied `RDFFormat`. Try out a few different formats yourself, to get a feel for what they look like.

The output in Turtle format looks like this:

[[code-example-05-output]]
[source, linenums]
----
@prefix ex: <http://example.org/> .

ex:Picasso a ex:Artist ;
	<http://xmlns.com/foaf/0.1/firstName> "Pablo" ;
	ex:homeAddress _:node1b4koq381x1 .

_:node1b4koq381x1 ex:street "31 Art Gallery" ;
	ex:city "Madrid" ;
	ex:country "Spain" .
----

If you compare this with the output of link:code-example-04-output[writing to RDF/XML], you will notice that the Turtle syntax format is a lot more compact, and also easier to read for a human. Let's quickly go through it:

On the first line, a namespaces prefix is defined. It is one we recognize: the `ex` namespace that we added to our RDF model earlier. Turtle syntax supports using prefixed names to make the format more compact, and easier to read.

Lines 3-5 show three RDF statements, all about `ex:Picasso`. 
The first statement, on line 3, says that Picasso is of type Artist. In Turtle, `a` is a shortcut for the `rdf:type` property. Notice that the line ends with a `;`. This indicates that the _next_ line in the file will be about the same subject. 
Line 4 says that Picasso's first name is "Pablo". Notice that here the full IRI is used for the property - this happens because we didn't set a namespace prefix for it when we created our model. 

TIP: In Turtle syntax, a full IRI always starts with `<` and ends with `>`. This makes them easy to distinguish from prefixed names, and from blank node identifiers. 

Line 5, finally, states that Picasso has a homeAddress, which is some blank node (a blank node identifier in Turtle syntax always starts with `_:`). Note that this line ends with a `.`, which indicates that we are done stating facts about the current subject.

Line 7 and further, finally, state facts about the blank node (the home address of Picasso): its street is "31 Art Gallery", its city is "Madrid", and its Country is "Spain".

=== Example 06: Reading a Turtle RDF file

Very similar to how we can write RDF models to files in various syntaxes, we can also use RDF4J Rio to _read_ files to produce an RDF model. 

https://github.com/eclipse/rdf4j-doc/examples/src/main/java/org/eclipse/rdf4j/examples/model/Example06ReadTurtle.java[Example 06] shows how we can read a Turtle file and produce a `Model` object out of it:

[[code-example-06]]
[source, java, linenums]
----
String filename = "example06-picasso.ttl";

// read the file 'example06-picasso.ttl' as an InputStream.
InputStream input = Example06ReadTurtle.class.getResourceAsStream("/" + filename);

// Rio also accepts a java.io.Reader as input for the parser.
Model model = Rio.parse(input, "", RDFFormat.TURTLE);
----
