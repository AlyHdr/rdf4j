include::../shared-settings.adoc[]
include::../header.adoc[]

:numbered!:
== How to use RDF and the Eclipse RDF4J Framework

Getting started with RDF can be hard. In this tutorial, we go through the basics of what RDF is and how you can use it, and we show how you can use the Eclipse RDF4J framework to create, process, store, and query RDF data. We assume that you know a little about programming in Java, but no prior knowledge on what RDF is is assumed.

The code examples in this tutorial are available for download from the https://github.com/eclipse/rdf4j-doc/examples[rdf4j-doc GitHub repository]. We encourage you to download these examples and play around with them.

:numbered:
== Introducing RDF

The https://www.w3.org/TR/rdf11-primer/[Resource Description Framework (RDF)] is a standard (or more accurately, a "recommendation") formulated by the https://www.w3.org/[World Wide Web Consortium (W3C)], the same organization that developed HTTP, HTML, and XML. The purpose of RDF is to provide a framework for expressing information about resources.

A _resource_ can be anything that we can stick an identifier on: a web page, an image, but also more abstract/real-world things like you, me, the concept of "world peace", the number 42, and that library book you never returned. 

RDF is intended for modeling information that needs to processed by applications, rather than just being shown to people. 

In this tutorial, we will be modeling information about artists . Let's start with a simple fact: "Picasso's first name is Pablo". In RDF, this could be expressed as follows:

image:rdf-graph-1.png[]

So what exactly are we looking at here? Well, we have a _resource_ "Picasso", denoted by an IRI (Internationalized _Resource Identifier_): `http://example.org/Picasso`. In RDF, resources have _properties_. Here we are using the `foaf:firstName` property to denote the relation between the resource "Picasso" and the value "Pablo". `foaf:firstName` is also an IRI, though to make things easier to read we use an abbreviated syntax, called _prefixed names_ (more about this later). Finally, the property value, "Pablo", is a _literal_ value: it is not represented using a resource identifier, but simply as a string of characters.

As you may have noticed, we have depicted our fact about Picasso as a simple *graph*: two nodes, connected by an edge. It is very helpful to think about RDF models as graphs, and a lot of the tools we will be using to create and query RDF data make a lot more sense if you do.

In RDF, each fact is called a *statement*. Each statement consists of three parts (for this reason, it is also often called a _triple_):

* the _subject_ is the starting node of the statement, representing the resource that the fact is "about";
* the _predicate_ is the property that denotes the edge between two nodes;
* the _object_ is the end node of the statement, representing the resource or literal that is the _property value_.

Let's expand our example slightly: we don't just have a single statement about Picasso, we know another fact as well: "Picasso is an artist". We can extend our RDF model as follows:

image:rdf-graph-2.png[]

Notice how the second statement was added to our graph depiction by simply adding a second edge to an already existing node , labeled with the `rdf:type` property, and the value `ex:Artist`. As you continue to add new facts to your data model, nodes and edges continue to be added to the graph.

=== IRIs, namespaces, and prefixed names

IRIs are at the core of what makes RDF powerful. They provide a mechanism that allows global identification of any resource: no matter who authors a dataset or where that data is physically stored, if that data shares an identical IRI with another dataset you know that both datasets are talking about the same thing. 

You will often see IRIs in abbreviated form whenever you encounter examples of RDF data: `<prefix>:<name>` This abbreviated form, known as "prefixed names", has no impact on the meaning of the data, but it makes it easier for people to read the data. 

Prefixed names work by defining a _prefix_ that is a replacement for a _namespace_. A namespace is the first part of an IRI that is shared by several resources. For example, the IRIs `http://example.org/Picasso`, `http://example.org/Rodin`, and `http://example.org/Rembrandt` all share the the namespace `http://example.org/`. By defining a new prefix `ex` as the abbreviation for this namespace, we can use the string `ex:Picasso` instead of its full IRI.

== Using RDF4J to create RDF models

Eclipse RDF4J is a Java API for RDF: it allows you to create, parse, write, store, query and reason with RDF data in a highly scalable manner. So let's see two examples of how we can use RDF4J to create the above RDF model in Java.

=== Example 01: building a simple Model 

https://github.com/eclipse/rdf4j-doc/examples/src/main/java/org/eclipse/rdf4j/examples/model/Example01BuildModel.java[Example 01] shows how we can create the RDF model we introduced above using RDF4J:

[[code-example-01]]
[source,java,linenums]
----
// We use a ValueFactory to create the building blocks of our RDF statements: 
// IRIs, blank nodes and literals.
ValueFactory vf = SimpleValueFactory.getInstance();

// We want to reuse this namespace when creating several building blocks.
String ex = "http://example.org/";

// Create IRIs for the resources we want to add.
IRI picasso = vf.createIRI(ex, "Picasso");
IRI artist = vf.createIRI(ex, "Artist");

// Create a new, empty Model object.
Model model = new TreeModel();

// add our first statement: Picasso is an Artist
model.add(picasso, RDF.TYPE, artist);

// second statement: Picasso's first name is "Pablo".
model.add(picasso, FOAF.FIRST_NAME, vf.createLiteral("Pablo"));
----

Let's take a closer look at this. Lines 1-10 are necessary preparation: we use a `ValueFactory` to create resources , which we will later use to add facts to our model. 

On line 13, we create a new, empty model. RDF4J comes with several `Model` implementations, the ones you will most commonly encounter are `TreeModel` and `LinkedHashModel`. The difference is in how they index data internally - which has a performance impact when working with very large models. For our purposes however, it doesn't really matter which implementation you use.

On lines 16 and 19, we add our two facts that we know about Picasso: that's he's an artist, and that his first name is "Pablo". 

In RDF4J, a `Model` is simply an in-memory collection of RDF statements. We can add statements to an existing model, remove statements from it, and of course iterate over the model to do things with its contents. As an example, let's iterate over all statements in our `Model` using a `for-each` loop, and print them to the screen:

[source, java, linenums]
----
for (Statement statement: model) {
    System.out.println(statement);
}
----

When you run this, the output will look something like this:

----
(http://example.org/Picasso, http://xmlns.com/foaf/0.1/firstName, "Pablo"^^<http://www.w3.org/2001/XMLSchema#string>) [null]
(http://example.org/Picasso, http://www.w3.org/1999/02/22-rdf-syntax-ns#type, http://example.org/art/Artist) [null]
----

Not very pretty perhaps, but at least you should be able to recognize the RDF statements that we originally added to our model. Each line is a single statement, with the subject, predicate, and object value in comma-separated form. The `[null]` behind each statement is a context identifier or named graph identifier, which you can safely ignore for now. The bit `^^<http://www.w3.org/2001/XMLSchema#string>` is a _datatype_ that RDF4J assigned to the literal value we added (in this case, the datatype is simply string). 

=== Example 02: using the ModelBuilder

The previous code example shows that you need to do a bit of prep on your data before actually adding anything to your model: defining common namespaces, creating a `ValueFactory`, creating IRIs, etc. As a convenience, RDF4J provides a `ModelBuilder` that simplifies things.

https://github.com/eclipse/rdf4j-doc/examples/src/main/java/org/eclipse/rdf4j/examples/model/Example02BuildModel.java[Example 02] shows how we can create the exact same model using a `ModelBuilder`:

[[code-example-02]]
[source, java, linenums]
----
ModelBuilder builder = new ModelBuilder();
Model model = builder
                  .setNamespace("ex", "http://example.org/")
		  .subject("ex:Picasso")
		       .add(RDF.TYPE, "ex:Artist")
		       .add(FOAF.FIRST_NAME, "Pablo")
		  .build();
----

The above bit of code creates the exact same model that we saw in link:#code-example-01[code example 01], but with far less prep. `ModelBuilder` accepts IRIs and prefixed names supplied as simple Java strings. On line 3 we define a namespace prefix we want to use, and then on lines 4-6 we use simple prefixed name strings, which the `ModelBuilder` internally maps to full IRIs.

== Blank nodes

Sometimes, we may want to model some facts without explicitly giving all resources involved in that fact an identifier. For example, consider the following sentenct: "Picasso has created a painting depicting cubes, and using a blue color scheme". There's several facts in this sentence:

1. Picasso created some painting;
2. that painting depicts cubes;
3. that painting uses the color blue.

All of the above may be true, but it doesn't involve identifying a specific painting. All we know is that there is _some_ (unknown) painting for which all of this is true. We can express this in RDF using a *blank node*.

When looking at a graph depiction of the RDF, it becomes obvious why it is called a _blank_ node:

image:rdf-graph-3.png[]

Other possible uses for blank nodes are for modeling a collection of facts that are strongly tied together. For example, "Picasso's home address is '31 Art Gallery, Madrid, Spain'" could be modeled as follows:

image:rdf-graph-4.png[]

=== Example 03: adding blank nodes to a Model

https://github.com/eclipse/rdf4j-doc/examples/src/main/java/org/eclipse/rdf4j/examples/model/Example03BlankNode.java[Example 03] shows how we can add the address of Picasso to our Model:

[[code-example-03]]
[source,java,linenum]
----
// To create a blank node for the address, we need a ValueFactory
ValueFactory vf = SimpleValueFactory.getInstance();
BNode address = vf.createBNode();

// First we do the same thing we did in example 02: create a new ModelBuilder,
// and add two statements about Picasso.
ModelBuilder builder = new ModelBuilder();
builder
    .setNamespace("ex", "http://example.org/")
    .subject("ex:Picasso")
	    .add(RDF.TYPE, "ex:Artist")
	    .add(FOAF.FIRST_NAME, "Pablo")
    // this is where it becomes new: we add the address by linking the blank 
    // node to picasso via the `ex:homeAddress` property, and then adding 
    // facts _about_ the address
	    .add("ex:homeAddress", address) // link the blank node
    .subject(address)			    // switch the subject
	    .add("ex:street", "31 Art Gallery")
	    .add("ex:city", "Madrid")
	    .add("ex:country", "Spain");

Model model = builder.build();
----


== Reading and Writing RDF

In the previous sections we saw how to print the contents of a Model to the screen, However, this is of limited use: the format is not easy to read, and certainly not by any other tools that you may wish to share the information with.

Fortunately, RDF4J provides tools for reading and writing RDF models in several syntax formats, all of which are standardized, and therefore can be used to share data between applications. The most commonly used formats are RDF/XML, Turtle, and N-Triples.

We can write our model in the desired syntax using RDF4J's Rio toolkit. For example, if we desire to see our model in Turtle syntax, simply replace the `for-each` loop in the previous code example by this:

[source, java]
----
Rio.write(rdfModel, System.out, RDFFormat.TURTLE);
----

The output will be similar to this:

----
@prefix ex: <http://example.org/> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .

ex:Picasso <http://xmlns.com/foaf/0.1/firstName> "Pablo" ;
	a ex:Artist ;
	ex:homeAddress _:node1b4ikqhq2x1 .

_:node1b4ikqhq2x1 ex:street "31 Art Gallery" ;
	ex:city "Madrid" ;
	ex:country "Spain" .
----

The `Rio.write` method takes a java `OutputStream` as an argument, so if we wish to write to file instead of to the screen, we can simply use a `FileOutputStream` and point it at the desired file location.

